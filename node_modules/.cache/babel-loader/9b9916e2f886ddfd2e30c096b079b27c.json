{"ast":null,"code":"/* Todo\n\t* Create a refresh button?\n\n\n*/\nexport default {\n  name: 'HelloWorld2',\n  props: {\n    msg2: String\n  },\n\n  data() {\n    return {\n      users: null,\n      filledData: null,\n      columns: null,\n      usersPerPage: 15,\n      currentPage: 1,\n      ascending: true,\n      sortCol: null,\n      message: null\n    };\n  },\n\n  async created() {\n    function sleep(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    const data_fetched = false; //Fetch the data upon creation of the component.\n\n    while (data_fetched === false) {\n      try {\n        const response = await fetch(\"http://dummy.restapiexample.com/api/v1/employees\");\n        const response_json = await response.json();\n        this.users = response_json.data;\n        this.message = response_json.message;\n        console.log(response_json);\n        break;\n      } catch (e) {\n        console.log(\"Error occured\");\n        await sleep(1000); // Some type of sleep function? Not really sure how this too many requests occur.\n\n        continue;\n      }\n    }\n\n    await this.fillOutData();\n    this.filledData[5][\"employee_name\"] = ''; //this.columns = this.updateColumns()\n  },\n\n  computed: {},\n  methods: {\n    fillOutData() {\n      /* We should not assume key-value pairs for the users are perfect.\n      \tSome implementation decisions:\n      \t*\tThe empty string is regarded as the zero value.\n      \t*\tIf one of the users has a key with a non zero value a column will\n       \t\tbe displayed for that key.\n      \t*\tIf a user does not have a value or a zero value for a key\n      \t\twhich another user has a value for, the empty string will be displayed for that user.\n      \tA consequence of these rules is that keys for which all users has the\n      zero value will be disregarded. As for the 'profile_image' data when this\n      was created.\n      */\n      let keyValues = [];\n      this.filledData = this.users; // Include all keys that some user has a value for.\n\n      for (let i = 0; i < this.filledData.length; i++) {\n        for (let key in this.filledData[i]) {\n          console.log(this.filledData[i][key]);\n\n          if (!keyValues.includes(key) && this.filledData[i][key] !== \"\") {\n            keyValues.push(key);\n          }\n        }\n      } // If there is a key that some user has a non-zero value,\n      // set zero values for that key for all other users.\n\n\n      for (let i = 0; i < this.filledData.length; i++) {\n        for (let j = 0; j < keyValues.length; j++) {\n          if (!(keyValues[j] in this.filledData[i])) {\n            this.filledData[i][keyValues[j]] = '';\n          }\n        }\n      } // The columns that are to be displayed correspond to the keyValues\n      // chosen here.\n\n\n      this.columns = keyValues;\n    },\n\n    /*\n    updateColumns () {\n    \t//Gets columns based on our computed value.\n    \tconst columns = []\n    \t\tif (this.filledData !== null) {\n    \t\t// Should try if an empty list crashes this!\n    \t\tfor (let key in this.filledData[0]) {\n    \t\t\tcolumns.push(key)\n    \t\t}\n    \t} else {\n    \t\tconsole.log(\"Return null in getColumns\")\n    \t\treturn null\n    \t}\n    \tconsole.log(\"Returning columns\")\n    \tconsole.log(columns)\n    \treturn columns\n    \t},\n    */\n    sortData(col) {\n      // Keep track of the last sorted column. Also keep track of if\n      // the data is sorted in a ascending or descending way. If the same\n      // column is sorted again, it is sorted in the other way.\n      if (this.sortCol === col) {\n        this.ascending = !this.ascending;\n      } else {\n        this.ascending = true;\n        this.sortCol = col;\n      }\n\n      var ascending = this.ascending;\n      this.filledData.sort(function (a, b) {\n        // Always shove zero values towards the bottom in sorting.\n        // Both for ascending and descending sorting.\n        if (a[col] === '' || b[col] === '') {\n          if (a[col] === '' && b[col] === '') {\n            return 0;\n          }\n\n          if (a[col] === '' && b[col] !== '') {\n            return 1;\n          } else {\n            return -1;\n          }\n        } // Sorting.\n\n\n        if (a[col] > b[col]) {\n          return this.ascending ? 1 : -1;\n        } else if (a[col] < b[col]) {\n          return this.ascending ? -1 : 1;\n        }\n\n        return 0;\n      });\n      console.log(col);\n    },\n\n    getRows() {\n      if (this.filledData === null) {\n        return null;\n      }\n\n      var start = (this.currentPage - 1) * this.usersPerPage;\n      var end = start + this.usersPerPage;\n      return this.filledData.slice(start, end);\n    },\n\n    numPages() {\n      if (this.filledData === null) {\n        return 0;\n      }\n\n      return Math.ceil(this.filledData.length / this.usersPerPage);\n    },\n\n    changePage(pageNum) {\n      this.currentPage = pageNum;\n    }\n\n  }\n};","map":{"version":3,"mappings":"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","names":["name","props","msg2","String","data","users","filledData","columns","usersPerPage","currentPage","ascending","sortCol","message","created","sleep","ms","Promise","resolve","setTimeout","data_fetched","response","fetch","response_json","json","console","log","e","fillOutData","computed","methods","keyValues","i","length","key","includes","push","j","sortData","col","sort","a","b","getRows","start","end","slice","numPages","Math","ceil","changePage","pageNum"],"sourceRoot":"","sources":["/Users/cakste/Desktop/website-v3/src/components/Table.vue"],"sourcesContent":["<template>\n\t<div class=\"table\">\n\t<h1 v-if=\"!filledData\">Loading data...</h1>\n\t<table id=\"myTable1\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<!---Setting the table headers to the key values dynamically.\n\t\t\t\t\tInterchanging underscore for space in table as well. -->\n\t\t\t\t<th v-for=\"(col, i) in columns\" :key=\"i\"\n\t\t\t\tv-on:click=\"sortData(col)\">{{ col.replaceAll('_', ' ') }}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr v-for=\"(user, i) in getRows()\" :key=\"i\">\n\t\t\t\t<!-- Instead of iterating over the keys in the user.\n\t\t\t\tThis doesn't require user data to always have the same order\n\t\t\t\tof key-value pairs. Accessing each value by the key instead.-->\n\t\t\t\t<td v-for=\"(col, i) in columns\" :key=\"i\">\n\t\t\t\t\t{{ user[col] }}\n\t\t\t\t</td>\n\t\t\t\t<!---\n\t\t\t\t<td v-for=\"(val, j) in user\" :key=\"j\">{{ val }}</td>\n\t\t\t\t<td>{{user.$(id)}}</td>\n\t\t\t\t-->\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t<div class=\"pagination\">\n\t\t<div class=\"number\"\n\t\tv-for=\"i in numPages()\" :key=\"i\"\n\t\tv-bind:class=\"[i == currentPage ? 'active' : '']\"\n\t\tv-on:click=\"changePage(i)\">{{i}}\n\t\t</div>\n\t</div>\n\t<p>{{ filledData }}</p>\n  </div>\n</template>\n\n\n\n<script>\n/* Todo\n\t* Create a refresh button?\n\n\n*/\n\nexport default {\n\tname: 'HelloWorld2',\n\tprops: {\n\t\tmsg2: String,\n\t},\n\n\tdata () {\n\t\treturn {\n\t\t\tusers: null,\n\t\t\tfilledData: null,\n\t\t\tcolumns: null,\n\t\t\tusersPerPage: 15,\n\t\t\tcurrentPage: 1,\n\t\t\tascending: true,\n\t\t\tsortCol: null,\n\t\t\tmessage: null,\n\t\t}\n\t},\n\n\tasync created () {\n\t\tfunction sleep(ms) {\n\t\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t\t}\n\n\t\tconst data_fetched = false\n\t\t//Fetch the data upon creation of the component.\n\t\twhile (data_fetched === false) {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(\"http://dummy.restapiexample.com/api/v1/employees\")\n\t\t\t\tconst response_json = await response.json()\n\n\t\t\t\tthis.users = response_json.data\n\t\t\t\tthis.message = response_json.message\n\t\t\t\tconsole.log(response_json)\n\t\t\t\tbreak;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"Error occured\")\n\n\t\t\t\tawait sleep(1000)\n\t\t\t\t// Some type of sleep function? Not really sure how this too many requests occur.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tawait this.fillOutData();\n\n\t\tthis.filledData[5][\"employee_name\"] = ''\n\n\t\t//this.columns = this.updateColumns()\n\n\t},\n\n\tcomputed: {\n\n\t},\n\n\tmethods: {\n\t\tfillOutData () {\n\t\t\t/* We should not assume key-value pairs for the users are perfect.\n\n\t\t\tSome implementation decisions:\n\t\t\t\t*\tThe empty string is regarded as the zero value.\n\t\t\t\t*\tIf one of the users has a key with a non zero value a column will\n\t\t\t \t\tbe displayed for that key.\n\t\t\t\t*\tIf a user does not have a value or a zero value for a key\n\t\t\t\t\twhich another user has a value for, the empty string will be displayed for that user.\n\n\t\t\tA consequence of these rules is that keys for which all users has the\n\t\t\tzero value will be disregarded. As for the 'profile_image' data when this\n\t\t\twas created.\n\t\t\t*/\n\n\t\t\tlet keyValues = []\n\t\t\tthis.filledData = this.users\n\n\t\t\t// Include all keys that some user has a value for.\n\t\t\tfor (let i = 0; i < this.filledData.length; i++) {\n\t\t\t\tfor (let key in this.filledData[i]) {\n\t\t\t\t\tconsole.log(this.filledData[i][key])\n\t\t\t\t\tif (!keyValues.includes(key) && this.filledData[i][key] !== \"\") {\n\t\t\t\t\t\tkeyValues.push(key)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is a key that some user has a non-zero value,\n\t\t\t// set zero values for that key for all other users.\n\t\t\tfor (let i = 0; i < this.filledData.length; i++) {\n\t\t\t\tfor (let j = 0; j < keyValues.length; j++) {\n\t\t\t\t\tif (!(keyValues[j] in this.filledData[i])) {\n\t\t\t\t\t\tthis.filledData[i][keyValues[j]] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The columns that are to be displayed correspond to the keyValues\n\t\t\t// chosen here.\n\t\t\tthis.columns = keyValues\n\t\t},\n\t\t/*\n\t\tupdateColumns () {\n\t\t\t//Gets columns based on our computed value.\n\t\t\tconst columns = []\n\n\t\t\tif (this.filledData !== null) {\n\t\t\t\t// Should try if an empty list crashes this!\n\t\t\t\tfor (let key in this.filledData[0]) {\n\t\t\t\t\tcolumns.push(key)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Return null in getColumns\")\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tconsole.log(\"Returning columns\")\n\t\t\tconsole.log(columns)\n\t\t\treturn columns\n\n\t\t},\n\t\t*/\n\t\tsortData (col) {\n\t\t\t// Keep track of the last sorted column. Also keep track of if\n\t\t\t// the data is sorted in a ascending or descending way. If the same\n\t\t\t// column is sorted again, it is sorted in the other way.\n\n\t\t\tif (this.sortCol === col) {\n\t\t\t\tthis.ascending = !this.ascending\n\t\t\t} else {\n\t\t\t\tthis.ascending = true\n\t\t\t\tthis.sortCol = col\n\t\t\t}\n\t\t\tvar ascending = this.ascending\n\t\t\tthis.filledData.sort(function(a,b) {\n\t\t\t\t// Always shove zero values towards the bottom in sorting.\n\t\t\t\t// Both for ascending and descending sorting.\n\t\t\t\tif (a[col] === '' || b[col] === '') {\n\t\t\t\t\tif (a[col] === '' && b[col] === '') {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\tif (a[col] === '' && b[col] !== '') {\n\t\t\t\t\t\treturn 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Sorting.\n\t\t\t\tif (a[col] > b[col]) {\n\t\t\t\t\treturn this.ascending ? 1 : -1\n\t\t\t\t} else if (a[col] < b[col]) {\n\t\t\t\t\treturn this.ascending ? -1 : 1\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t})\n\t\t\tconsole.log(col)\n\t\t},\n\t\tgetRows () {\n\t\t\tif (this.filledData === null) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tvar start = (this.currentPage - 1) * this.usersPerPage\n\t\t\tvar end = start + this.usersPerPage\n\t\t\treturn this.filledData.slice(start, end)\n\n\t\t},\n\t\tnumPages () {\n\t\t\tif (this.filledData === null) {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\treturn Math.ceil(this.filledData.length / this.usersPerPage)\n\t\t},\n\t\tchangePage (pageNum) {\n\t\t\tthis.currentPage = pageNum\n\t\t}\n\t}\n}\n\n</script>\n\n<style scoped>\ntable {\n  font-family: 'Open Sans', sans-serif;\n  width: 750px;\n  border-collapse: collapse;\n  border: 5px solid #44475C;\n  margin: 10px 10px 0 10px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\ntable th {\n  text-transform: uppercase;\n  text-align: left;\n  background: #44475C;\n  color: #FFF;\n  cursor: pointer;\n  padding: 8px;\n  min-width: 30px;\n}\ntable th:hover {\n        background: #717699;\n      }\ntable td {\n  text-align: left;\n  padding: 8px;\n  border-right: 2px solid #7D82A8;\n}\ntable td:last-child {\n  border-right: none;\n}\ntable tbody tr:nth-child(2n) td {\n  background: #D4D8F9;\n}\n\n.pagination {\n  font-family: 'Open Sans', sans-serif;\n  text-align: right;\n  width: 750px;\n  padding: 8px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.arrow {\n  float: right;\n  width: 12px;\n  height: 15px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position-y: bottom;\n}\n\n.number {\n  display: inline-block;\n  padding: 4px 10px;\n  color: #FFF;\n  border-radius: 4px;\n  background: #44475C;\n  margin: 0px 5px;\n  cursor: pointer;\n}\n.number:hover, .number.active {\n  background: #717699;\n}\n\n\n</style>\n"]},"metadata":{},"sourceType":"module"}