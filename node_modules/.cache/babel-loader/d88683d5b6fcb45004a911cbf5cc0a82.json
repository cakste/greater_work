{"ast":null,"code":"export default {\n  name: 'DataTable',\n  props: {\n    msg2: String\n  },\n\n  data() {\n    return {\n      users: null,\n      filledData: null,\n      columns: null,\n      usersPerPage: 12,\n      currentPage: 1,\n      ascending: true,\n      sortCol: null,\n      maxColumns: 5\n    };\n  },\n\n  async created() {\n    function sleep(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    const data_fetched = false; //Fetch the data upon creation of the component.\n\n    while (data_fetched === false) {\n      try {\n        const response = await fetch(\"http://dummy.restapiexample.com/api/v1/employees\");\n        const response_json = await response.json();\n        this.users = response_json.data;\n        this.message = response_json.message;\n        console.log(response_json);\n        break;\n      } catch (e) {\n        let sleep_time = 300; //Math.floor(Math.random()*400+100)\n\n        await sleep(sleep_time); // Some type of sleep function? Not really sure how this too many requests occur.\n\n        continue;\n      }\n    }\n\n    await this.fillOutData(); //this.users[5][\"employee_name\"] = ''\n    //this.columns = this.updateColumns()\n  },\n\n  computed: {},\n  methods: {\n    fillOutData() {\n      /* We should not assume key-value pairs for the users are perfect.\n      \tSome implementation decisions:\n      \t*\tThe empty string is regarded as the zero value.\n      \t*\tIf one of the users has a key with a non zero value a column will\n       \t\tbe displayed for that key.\n      \t*\tIf a user does not have a value or a zero value for a key\n      \t\twhich another user has a value for, the empty string will be displayed for that user.\n      \tA consequence of these rules is that keys for which all users has the\n      zero value will be disregarded. As for the 'profile_image' data when this\n      was created.\n      */\n      let keyValues = [];\n      var valueCounts = {};\n      this.filledData = this.users; // Include all keys that some user has a value for.\n\n      for (let i = 0; i < this.filledData.length; i++) {\n        for (let key in this.filledData[i]) {\n          if (this.filledData[i][key] !== \"\") {\n            if (!keyValues.includes(key)) {\n              keyValues.push(key);\n              valueCounts[key] = 1;\n            } else {\n              valueCounts[key]++;\n            }\n          }\n          /*\n          if (!keyValues.includes(key) && this.filledData[i][key] !== \"\") {\n          \tkeyValues.push(key)\n          }\n          */\n\n        }\n      }\n\n      console.log(valueCounts);\n      /*\n      \tTake out maxColumns number of keys which has the most non-zero values\n      \tamongst all users.\n      */\n\n      if (keyValues.length > this.maxColumns) {\n        var items = Object.keys(valueCounts).map(key => {\n          return [key, valueCounts[key]];\n        });\n        items.sort((first, second) => {\n          return -(first[1] - second[1]);\n        });\n        keyValues = items.map(e => {\n          return e[0];\n        });\n        console.log(keyValues);\n        keyValues = keyValues.slice(0, this.maxColumns);\n      } // If there is a key that some user has a non-zero value,\n      // set zero values for that key for all other users.\n\n\n      for (let i = 0; i < this.filledData.length; i++) {\n        for (let j = 0; j < keyValues.length; j++) {\n          if (!(keyValues[j] in this.filledData[i])) {\n            this.filledData[i][keyValues[j]] = '';\n          }\n        }\n      } // The columns that are to be displayed correspond to the keyValues\n      // chosen here.\n\n\n      this.columns = keyValues;\n    },\n\n    /*\n    updateColumns () {\n    \t//Gets columns based on our computed value.\n    \tconst columns = []\n    \t\tif (this.filledData !== null) {\n    \t\t// Should try if an empty list crashes this!\n    \t\tfor (let key in this.filledData[0]) {\n    \t\t\tcolumns.push(key)\n    \t\t}\n    \t} else {\n    \t\tconsole.log(\"Return null in getColumns\")\n    \t\treturn null\n    \t}\n    \tconsole.log(\"Returning columns\")\n    \tconsole.log(columns)\n    \treturn columns\n    \t},\n    */\n    sortData(col) {\n      // Keep track of the last sorted column. Also keep track of if\n      // the data is sorted in a ascending or descending way. If the same\n      // column is sorted again, it is sorted in the other way.\n      if (this.sortCol === col) {\n        this.ascending = !this.ascending;\n      } else {\n        this.ascending = true;\n        this.sortCol = col;\n      }\n\n      var ascending = this.ascending;\n      this.filledData.sort(function (a, b) {\n        // Always shove zero values towards the bottom in sorting.\n        // Both for ascending and descending sorting.\n        if (a[col] === '' || b[col] === '') {\n          if (a[col] === '' && b[col] === '') {\n            return 0;\n          }\n\n          if (a[col] === '' && b[col] !== '') {\n            return 1;\n          } else {\n            return -1;\n          }\n        } // Sorting.\n\n\n        if (a[col] > b[col]) {\n          return ascending ? 1 : -1;\n        } else if (a[col] < b[col]) {\n          return ascending ? -1 : 1;\n        }\n\n        return 0;\n      });\n      console.log(col);\n    },\n\n    getRows() {\n      if (this.filledData === null) {\n        return null;\n      }\n\n      var start = (this.currentPage - 1) * this.usersPerPage;\n      var end = start + this.usersPerPage;\n      return this.filledData.slice(start, end);\n    },\n\n    numPages() {\n      if (this.filledData === null) {\n        return 0;\n      }\n\n      return Math.ceil(this.filledData.length / this.usersPerPage);\n    },\n\n    changePage(pageNum) {\n      this.currentPage = pageNum;\n    }\n\n  }\n};","map":{"version":3,"mappings":"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","names":["name","props","msg2","String","data","users","filledData","columns","usersPerPage","currentPage","ascending","sortCol","maxColumns","created","sleep","ms","Promise","resolve","setTimeout","data_fetched","response","fetch","response_json","json","message","console","log","e","sleep_time","fillOutData","computed","methods","keyValues","valueCounts","i","length","key","includes","push","items","Object","keys","map","sort","first","second","slice","j","sortData","col","a","b","getRows","start","end","numPages","Math","ceil","changePage","pageNum"],"sourceRoot":"","sources":["/Users/cakste/test/greater_work/src/components/Table.vue"],"sourcesContent":["<template>\n\t<div class=\"table\">\n\t<h1 v-if=\"!filledData\">Loading data...</h1>\n\t<table id=\"myTable1\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<!---Setting the table headers to the key values dynamically.\n\t\t\t\t\tInterchanging underscore for space in table as well. -->\n\t\t\t\t<th v-for=\"(col, i) in columns\" :key=\"i\"\n\t\t\t\tv-on:click=\"sortData(col)\">{{ col.replaceAll('_', ' ') }}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr v-for=\"(user, i) in getRows()\" :key=\"i\">\n\t\t\t\t<!-- Instead of iterating over the keys in the user.\n\t\t\t\tThis doesn't require user data to always have the same order\n\t\t\t\tof key-value pairs. Accessing each value by the key instead.-->\n\t\t\t\t<td v-for=\"(col, i) in columns\" :key=\"i\">\n\t\t\t\t\t{{ user[col] }}\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t<div class=\"pagination\">\n\t\t<div class=\"number\"\n\t\tv-for=\"i in numPages()\" :key=\"i\"\n\t\tv-bind:class=\"[i == currentPage ? 'active' : '']\"\n\t\tv-on:click=\"changePage(i)\">{{i}}\n\t\t</div>\n\t</div>\n  </div>\n</template>\n\n\n\n<script>\n\nexport default {\n\tname: 'DataTable',\n\tprops: {\n\t\tmsg2: String,\n\t},\n\n\tdata () {\n\t\treturn {\n\t\t\tusers: null,\n\t\t\tfilledData: null,\n\t\t\tcolumns: null,\n\t\t\tusersPerPage: 12,\n\t\t\tcurrentPage: 1,\n\t\t\tascending: true,\n\t\t\tsortCol: null,\n\t\t\tmaxColumns: 5,\n\t\t}\n\t},\n\n\tasync created () {\n\t\tfunction sleep(ms) {\n\t\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t\t}\n\n\t\tconst data_fetched = false\n\t\t//Fetch the data upon creation of the component.\n\t\twhile (data_fetched === false) {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(\"http://dummy.restapiexample.com/api/v1/employees\")\n\t\t\t\tconst response_json = await response.json()\n\n\t\t\t\tthis.users = response_json.data\n\t\t\t\tthis.message = response_json.message\n\t\t\t\tconsole.log(response_json)\n\t\t\t\tbreak;\n\t\t\t} catch (e) {\n\t\t\t\tlet sleep_time = 300//Math.floor(Math.random()*400+100)\n\t\t\t\tawait sleep(sleep_time)\n\t\t\t\t// Some type of sleep function? Not really sure how this too many requests occur.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tawait this.fillOutData();\n\n\t\t//this.users[5][\"employee_name\"] = ''\n\n\t\t//this.columns = this.updateColumns()\n\n\t},\n\n\tcomputed: {\n\n\t},\n\n\tmethods: {\n\t\tfillOutData () {\n\t\t\t/* We should not assume key-value pairs for the users are perfect.\n\n\t\t\tSome implementation decisions:\n\t\t\t\t*\tThe empty string is regarded as the zero value.\n\t\t\t\t*\tIf one of the users has a key with a non zero value a column will\n\t\t\t \t\tbe displayed for that key.\n\t\t\t\t*\tIf a user does not have a value or a zero value for a key\n\t\t\t\t\twhich another user has a value for, the empty string will be displayed for that user.\n\n\t\t\tA consequence of these rules is that keys for which all users has the\n\t\t\tzero value will be disregarded. As for the 'profile_image' data when this\n\t\t\twas created.\n\t\t\t*/\n\n\t\t\tlet keyValues = []\n\t\t\tvar valueCounts = {}\n\t\t\tthis.filledData = this.users\n\n\t\t\t// Include all keys that some user has a value for.\n\t\t\tfor (let i = 0; i < this.filledData.length; i++) {\n\t\t\t\tfor (let key in this.filledData[i]) {\n\t\t\t\t\tif (this.filledData[i][key] !== \"\") {\n\t\t\t\t\t\tif (!keyValues.includes(key)) {\n\t\t\t\t\t\t\tkeyValues.push(key)\n\t\t\t\t\t\t\tvalueCounts[key] = 1\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalueCounts[key]++\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\tif (!keyValues.includes(key) && this.filledData[i][key] !== \"\") {\n\t\t\t\t\t\tkeyValues.push(key)\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(valueCounts)\n\n\t\t\t/*\n\t\t\t\tTake out maxColumns number of keys which has the most non-zero values\n\t\t\t\tamongst all users.\n\t\t\t*/\n\t\t\tif (keyValues.length > this.maxColumns) {\n\t\t\t\tvar items = Object.keys(valueCounts).map(\n\t\t\t\t\t(key) => {return [key, valueCounts[key]]});\n\t\t\t\titems.sort(\n\t\t\t\t\t(first, second) => { return -(first[1] - second[1]) }\n\t\t\t\t);\n\t\t\t\tkeyValues = items.map(\n\t\t\t\t\t(e) => {return e[0]}\n\t\t\t\t);\n\t\t\t\tconsole.log(keyValues)\n\t\t\t\tkeyValues = keyValues.slice(0, this.maxColumns)\n\t\t\t}\n\n\n\t\t\t// If there is a key that some user has a non-zero value,\n\t\t\t// set zero values for that key for all other users.\n\t\t\tfor (let i = 0; i < this.filledData.length; i++) {\n\t\t\t\tfor (let j = 0; j < keyValues.length; j++) {\n\t\t\t\t\tif (!(keyValues[j] in this.filledData[i])) {\n\t\t\t\t\t\tthis.filledData[i][keyValues[j]] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The columns that are to be displayed correspond to the keyValues\n\t\t\t// chosen here.\n\t\t\tthis.columns = keyValues\n\t\t},\n\t\t/*\n\t\tupdateColumns () {\n\t\t\t//Gets columns based on our computed value.\n\t\t\tconst columns = []\n\n\t\t\tif (this.filledData !== null) {\n\t\t\t\t// Should try if an empty list crashes this!\n\t\t\t\tfor (let key in this.filledData[0]) {\n\t\t\t\t\tcolumns.push(key)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Return null in getColumns\")\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tconsole.log(\"Returning columns\")\n\t\t\tconsole.log(columns)\n\t\t\treturn columns\n\n\t\t},\n\t\t*/\n\t\tsortData (col) {\n\t\t\t// Keep track of the last sorted column. Also keep track of if\n\t\t\t// the data is sorted in a ascending or descending way. If the same\n\t\t\t// column is sorted again, it is sorted in the other way.\n\n\t\t\tif (this.sortCol === col) {\n\t\t\t\tthis.ascending = !this.ascending\n\t\t\t} else {\n\t\t\t\tthis.ascending = true\n\t\t\t\tthis.sortCol = col\n\t\t\t}\n\n\t\t\tvar ascending = this.ascending\n\t\t\tthis.filledData.sort(function(a,b) {\n\t\t\t\t// Always shove zero values towards the bottom in sorting.\n\t\t\t\t// Both for ascending and descending sorting.\n\t\t\t\tif (a[col] === '' || b[col] === '') {\n\t\t\t\t\tif (a[col] === '' && b[col] === '') {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\tif (a[col] === '' && b[col] !== '') {\n\t\t\t\t\t\treturn 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Sorting.\n\t\t\t\tif (a[col] > b[col]) {\n\t\t\t\t\treturn ascending ? 1 : -1\n\t\t\t\t} else if (a[col] < b[col]) {\n\t\t\t\t\treturn ascending ? -1 : 1\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t})\n\t\t\tconsole.log(col)\n\t\t},\n\t\tgetRows () {\n\t\t\tif (this.filledData === null) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tvar start = (this.currentPage - 1) * this.usersPerPage\n\t\t\tvar end = start + this.usersPerPage\n\t\t\treturn this.filledData.slice(start, end)\n\n\t\t},\n\t\tnumPages () {\n\t\t\tif (this.filledData === null) {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\treturn Math.ceil(this.filledData.length / this.usersPerPage)\n\t\t},\n\t\tchangePage (pageNum) {\n\t\t\tthis.currentPage = pageNum\n\t\t}\n\t}\n}\n\n</script>\n\n<style scoped>\ntable {\n  font-family: Poppins, sans-serif;\n  width: 750px;\n  border-collapse: collapse;\n  border: 5px solid #1cba93;\n  margin: 40px 10px 0 10px;\n  margin-left: auto;\n  margin-right: auto;\n  box-shadow:\n  0px 0px 20px rgba(0,0,0,0.10),\n  0px 10px 20px rgba(0,0,0,0.05),\n  0px 20px 20px rgba(0,0,0,0.05),\n  0px 30px 20px rgba(0,0,0,0.05);\n\n}\n\n\ntable th {\n  text-transform: uppercase;\n  text-align: left;\n  background: #1cba93;\n  color: #FFF;\n  cursor: pointer;\n  padding: 8px;\n  min-width: 30px;\n}\ntable th:hover {\n        background: #6fcbb5;\n      }\ntable td {\n  text-align: left;\n  padding: 8px;\n  border-right: 2px solid #7D82A8;\n}\ntable td:last-child {\n  border-right: none;\n}\ntable tbody tr:nth-child(2n) td {\n  background: #f1eff7;\n}\n\n.pagination {\n  font-family: poppins, sans-serif;\n  text-align: right;\n  width: 750px;\n  padding: 8px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.arrow {\n  float: right;\n  width: 12px;\n  height: 15px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position-y: bottom;\n}\n\n.number {\n  display: inline-block;\n  padding: 4px 10px;\n  color: #FFF;\n  border-radius: 4px;\n  background: #1cba93;\n  margin: 0px 5px;\n  cursor: pointer;\n}\n.number:hover, .number.active {\n  background: #6fcbb5;\n}\n\n\n</style>\n"]},"metadata":{},"sourceType":"module"}