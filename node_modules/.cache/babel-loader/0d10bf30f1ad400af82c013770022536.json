{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, renderList as _renderList, Fragment as _Fragment, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, normalizeClass as _normalizeClass, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-783f90ce\"), n = n(), _popScopeId(), n);\n\nconst _hoisted_1 = {\n  class: \"table\"\n};\nconst _hoisted_2 = {\n  key: 0\n};\nconst _hoisted_3 = {\n  id: \"myTable1\"\n};\nconst _hoisted_4 = [\"onClick\"];\nconst _hoisted_5 = {\n  class: \"pagination\"\n};\nconst _hoisted_6 = [\"onClick\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [!$data.filledData ? (_openBlock(), _createElementBlock(\"h1\", _hoisted_2, \"Loading data...\")) : _createCommentVNode(\"v-if\", true), _createElementVNode(\"table\", _hoisted_3, [_createElementVNode(\"thead\", null, [_createElementVNode(\"tr\", null, [_createCommentVNode(\"-Setting the table headers to the key values dynamically.\\n\\t\\t\\t\\t\\tInterchanging underscore for space in table as well. \"), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.columns, (col, i) => {\n    return _openBlock(), _createElementBlock(\"th\", {\n      key: i,\n      onClick: $event => $options.sortData(col)\n    }, _toDisplayString(col.replaceAll('_', ' ')), 9\n    /* TEXT, PROPS */\n    , _hoisted_4);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]), _createElementVNode(\"tbody\", null, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.getRows(), (user, i) => {\n    return _openBlock(), _createElementBlock(\"tr\", {\n      key: i\n    }, [_createCommentVNode(\" Instead of iterating over the keys in the user.\\n\\t\\t\\t\\tThis doesn't require user data to always have the same order\\n\\t\\t\\t\\tof key-value pairs. Accessing each value by the key instead.\"), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.columns, (col, i) => {\n      return _openBlock(), _createElementBlock(\"td\", {\n        key: i\n      }, _toDisplayString(user[col]), 1\n      /* TEXT */\n      );\n    }), 128\n    /* KEYED_FRAGMENT */\n    )), _createCommentVNode(\"-\\n\\t\\t\\t\\t<td v-for=\\\"(val, j) in user\\\" :key=\\\"j\\\">{{ val }}</td>\\n\\t\\t\\t\\t<td>{{user.$(id)}}</td>\\n\\t\\t\\t\\t\")]);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]), _createElementVNode(\"div\", _hoisted_5, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($options.numPages(), i => {\n    return _openBlock(), _createElementBlock(\"div\", {\n      class: _normalizeClass([\"number\", [i == $data.currentPage ? 'active' : '']]),\n      key: i,\n      onClick: $event => $options.changePage(i)\n    }, _toDisplayString(i), 11\n    /* TEXT, CLASS, PROPS */\n    , _hoisted_6);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]);\n}","map":{"version":3,"mappings":";;;;;AACMA,OAAK,EAAC;;;;;;AAEJC,IAAE,EAAC;;;;AAwBLD,OAAK,EAAC;;;;uBA1BXE,oBAiCO,KAjCP,cAiCO,EAhCIC,kCAAXD,oBAA2C,IAA3C,EAA2CE,UAA3C,EAAuB,iBAAvB,sCAgCO,EA/BPC,oBAuBQ,OAvBR,cAuBQ,CAtBPA,oBAOQ,OAPR,EAOQ,IAPR,EAOQ,CANPA,oBAKK,IALL,EAKK,IALL,EAKK,CAJJC,iJAII,qBAFJJ,oBAC8DK,SAD9D,EAC8D,IAD9D,EAC8DC,YADvCL,aACuC,EADhC,CAAlBM,GAAkB,EAAbC,CAAa,KAAZ;yBAAlBR,oBAC8D,IAD9D,EAC8D;AAD7BS,SAAG,EAAED,CACwB;AAAzDE,aAAK,YAAEC,kBAASJ,GAAT;AAAkD,KAD9D,mBAC8BA,GAAG,CAACK,UAAJ,CAAc,GAAd,EAAc,GAAd,EAD9B,EAC4C;AAAA;AAD5C,MAC4CC,UAD5C;GAC8D,CAD9D;;AAAA,GAEI,EALL,CAMO,CAPR,CAsBO,EAdPV,oBAaQ,OAbR,EAaQ,IAbR,EAaQ,oBAZPH,oBAWKK,SAXL,EAWK,IAXL,EAWKC,YAXmBK,kBAWnB,EAX0B,CAAnBG,IAAmB,EAAbN,CAAa,KAAZ;yBAAnBR,oBAWK,IAXL,EAWK;AAX+BS,SAAG,EAAED;AAWpC,KAXL,EAA0C,CACzCJ,mNADyC,qBAIzCJ,oBAEKK,SAFL,EAEK,IAFL,EAEKC,YAFkBL,aAElB,EAFyB,CAAlBM,GAAkB,EAAbC,CAAa,KAAZ;2BAAlBR,oBAEK,IAFL,EAEK;AAF4BS,WAAG,EAAED;AAEjC,OAFL,EAAuCO,iBACnCD,IAAI,CAACP,GAAD,CAD+B,CAAvC,EACY;AAAA;AADZ;KAEK,CAFL;;AAAA,KAJyC,GAOzCH,qIAPyC,CAA1C;GAWK,CAXL;;AAAA,GAYO,EAbR,CAcO,CAvBR,CA+BO,EAPPD,oBAMM,KANN,cAMM,oBALLH,oBAIMK,SAJN,EAIM,IAJN,EAIMC,YAHMK,mBAGN,EAHCH,CAAa,IAAZ;yBADRR,oBAIM,KAJN,EAIM;AAJDF,WAAK,mBAAC,QAAD,EAAS,CAEJU,CAAC,IAAIP,iBAAL,GAAgB,QAAhB,GAAgB,EAFZ,CAAT,EAIJ;AAHmBQ,SAAG,EAAED,CAGxB;AADDE,aAAK,YAAEC,oBAAWH,CAAX;AACN,KAJN,mBAG6BA,EAH7B,EAG8B;AAAA;AAH9B,MAG8BQ,UAH9B;GAIM,CAJN;;AAAA,GAKK,EANN,CAOO,CAjCP","names":["class","id","_createElementBlock","$data","_hoisted_2","_createElementVNode","_createCommentVNode","_Fragment","_renderList","col","i","key","onClick","$options","replaceAll","_hoisted_4","user","_toDisplayString","_hoisted_6"],"sourceRoot":"","sources":["/Users/cakste/Desktop/website-v3/src/components/Table.vue"],"sourcesContent":["<template>\n\t<div class=\"table\">\n\t<h1 v-if=\"!filledData\">Loading data...</h1>\n\t<table id=\"myTable1\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<!---Setting the table headers to the key values dynamically.\n\t\t\t\t\tInterchanging underscore for space in table as well. -->\n\t\t\t\t<th v-for=\"(col, i) in columns\" :key=\"i\"\n\t\t\t\tv-on:click=\"sortData(col)\">{{ col.replaceAll('_', ' ') }}</th>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr v-for=\"(user, i) in getRows()\" :key=\"i\">\n\t\t\t\t<!-- Instead of iterating over the keys in the user.\n\t\t\t\tThis doesn't require user data to always have the same order\n\t\t\t\tof key-value pairs. Accessing each value by the key instead.-->\n\t\t\t\t<td v-for=\"(col, i) in columns\" :key=\"i\">\n\t\t\t\t\t{{ user[col] }}\n\t\t\t\t</td>\n\t\t\t\t<!---\n\t\t\t\t<td v-for=\"(val, j) in user\" :key=\"j\">{{ val }}</td>\n\t\t\t\t<td>{{user.$(id)}}</td>\n\t\t\t\t-->\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t<div class=\"pagination\">\n\t\t<div class=\"number\"\n\t\tv-for=\"i in numPages()\" :key=\"i\"\n\t\tv-bind:class=\"[i == currentPage ? 'active' : '']\"\n\t\tv-on:click=\"changePage(i)\">{{i}}\n\t\t</div>\n\t</div>\n  </div>\n</template>\n\n\n\n<script>\n/* Todo\n\t* Create a refresh button?\n\n\n*/\n\nexport default {\n\tname: 'HelloWorld2',\n\tprops: {\n\t\tmsg2: String,\n\t},\n\n\tdata () {\n\t\treturn {\n\t\t\tusers: null,\n\t\t\tfilledData: null,\n\t\t\tcolumns: null,\n\t\t\tusersPerPage: 15,\n\t\t\tcurrentPage: 1,\n\t\t\tascending: true,\n\t\t\tsortCol: null,\n\t\t\tmessage: null,\n\t\t}\n\t},\n\n\tasync created () {\n\t\tfunction sleep(ms) {\n\t\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t\t}\n\n\t\tconst data_fetched = false\n\t\t//Fetch the data upon creation of the component.\n\t\twhile (data_fetched === false) {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(\"http://dummy.restapiexample.com/api/v1/employees\")\n\t\t\t\tconst response_json = await response.json()\n\n\t\t\t\tthis.users = response_json.data\n\t\t\t\tthis.message = response_json.message\n\t\t\t\tconsole.log(response_json)\n\t\t\t\tbreak;\n\t\t\t} catch (e) {\n\t\t\t\tlet sleep_time = Math.floor(Math.random()*400+100)\n\t\t\t\tawait sleep(sleep_time)\n\t\t\t\t// Some type of sleep function? Not really sure how this too many requests occur.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tawait this.fillOutData();\n\n\t\tthis.filledData[5][\"employee_name\"] = ''\n\n\t\t//this.columns = this.updateColumns()\n\n\t},\n\n\tcomputed: {\n\n\t},\n\n\tmethods: {\n\t\tfillOutData () {\n\t\t\t/* We should not assume key-value pairs for the users are perfect.\n\n\t\t\tSome implementation decisions:\n\t\t\t\t*\tThe empty string is regarded as the zero value.\n\t\t\t\t*\tIf one of the users has a key with a non zero value a column will\n\t\t\t \t\tbe displayed for that key.\n\t\t\t\t*\tIf a user does not have a value or a zero value for a key\n\t\t\t\t\twhich another user has a value for, the empty string will be displayed for that user.\n\n\t\t\tA consequence of these rules is that keys for which all users has the\n\t\t\tzero value will be disregarded. As for the 'profile_image' data when this\n\t\t\twas created.\n\t\t\t*/\n\n\t\t\tlet keyValues = []\n\t\t\tthis.filledData = this.users\n\n\t\t\t// Include all keys that some user has a value for.\n\t\t\tfor (let i = 0; i < this.filledData.length; i++) {\n\t\t\t\tfor (let key in this.filledData[i]) {\n\t\t\t\t\tif (!keyValues.includes(key) && this.filledData[i][key] !== \"\") {\n\t\t\t\t\t\tkeyValues.push(key)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is a key that some user has a non-zero value,\n\t\t\t// set zero values for that key for all other users.\n\t\t\tfor (let i = 0; i < this.filledData.length; i++) {\n\t\t\t\tfor (let j = 0; j < keyValues.length; j++) {\n\t\t\t\t\tif (!(keyValues[j] in this.filledData[i])) {\n\t\t\t\t\t\tthis.filledData[i][keyValues[j]] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The columns that are to be displayed correspond to the keyValues\n\t\t\t// chosen here.\n\t\t\tthis.columns = keyValues\n\t\t},\n\t\t/*\n\t\tupdateColumns () {\n\t\t\t//Gets columns based on our computed value.\n\t\t\tconst columns = []\n\n\t\t\tif (this.filledData !== null) {\n\t\t\t\t// Should try if an empty list crashes this!\n\t\t\t\tfor (let key in this.filledData[0]) {\n\t\t\t\t\tcolumns.push(key)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Return null in getColumns\")\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tconsole.log(\"Returning columns\")\n\t\t\tconsole.log(columns)\n\t\t\treturn columns\n\n\t\t},\n\t\t*/\n\t\tsortData (col) {\n\t\t\t// Keep track of the last sorted column. Also keep track of if\n\t\t\t// the data is sorted in a ascending or descending way. If the same\n\t\t\t// column is sorted again, it is sorted in the other way.\n\n\t\t\tif (this.sortCol === col) {\n\t\t\t\tthis.ascending = !this.ascending\n\t\t\t} else {\n\t\t\t\tthis.ascending = true\n\t\t\t\tthis.sortCol = col\n\t\t\t}\n\n\t\t\tvar ascending = this.ascending\n\t\t\tthis.filledData.sort(function(a,b) {\n\t\t\t\t// Always shove zero values towards the bottom in sorting.\n\t\t\t\t// Both for ascending and descending sorting.\n\t\t\t\tif (a[col] === '' || b[col] === '') {\n\t\t\t\t\tif (a[col] === '' && b[col] === '') {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\tif (a[col] === '' && b[col] !== '') {\n\t\t\t\t\t\treturn 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Sorting.\n\t\t\t\tif (a[col] > b[col]) {\n\t\t\t\t\treturn ascending ? 1 : -1\n\t\t\t\t} else if (a[col] < b[col]) {\n\t\t\t\t\treturn ascending ? -1 : 1\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t})\n\t\t\tconsole.log(col)\n\t\t},\n\t\tgetRows () {\n\t\t\tif (this.filledData === null) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tvar start = (this.currentPage - 1) * this.usersPerPage\n\t\t\tvar end = start + this.usersPerPage\n\t\t\treturn this.filledData.slice(start, end)\n\n\t\t},\n\t\tnumPages () {\n\t\t\tif (this.filledData === null) {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\treturn Math.ceil(this.filledData.length / this.usersPerPage)\n\t\t},\n\t\tchangePage (pageNum) {\n\t\t\tthis.currentPage = pageNum\n\t\t}\n\t}\n}\n\n</script>\n\n<style scoped>\ntable {\n  font-family: 'Open Sans', sans-serif;\n  width: 750px;\n  border-collapse: collapse;\n  border: 5px solid #44475C;\n  margin: 10px 40px 0 10px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\ntable th {\n  text-transform: uppercase;\n  text-align: left;\n  background: #44475C;\n  color: #FFF;\n  cursor: pointer;\n  padding: 8px;\n  min-width: 30px;\n}\ntable th:hover {\n        background: #717699;\n      }\ntable td {\n  text-align: left;\n  padding: 8px;\n  border-right: 2px solid #7D82A8;\n}\ntable td:last-child {\n  border-right: none;\n}\ntable tbody tr:nth-child(2n) td {\n  background: #D4D8F9;\n}\n\n.pagination {\n  font-family: 'Open Sans', sans-serif;\n  text-align: right;\n  width: 750px;\n  padding: 8px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.arrow {\n  float: right;\n  width: 12px;\n  height: 15px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position-y: bottom;\n}\n\n.number {\n  display: inline-block;\n  padding: 4px 10px;\n  color: #FFF;\n  border-radius: 4px;\n  background: #44475C;\n  margin: 0px 5px;\n  cursor: pointer;\n}\n.number:hover, .number.active {\n  background: #717699;\n}\n\n\n</style>\n"]},"metadata":{},"sourceType":"module"}